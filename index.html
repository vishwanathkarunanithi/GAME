<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vijay Action Game</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            background-color: #000;
            color: white;
            touch-action: none; /* Prevent browser zooming/swiping */
        }

        /* WALLPAPER SETTING */
        #game-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* Vijay Wallpaper */
            background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.6)), url('https://images.unsplash.com/photo-1489599849927-2ee91cede3ba?q=80&w=2070&auto=format&fit=crop');
            background-size: cover;
            background-position: center;
        }

        /* Virtual Controller Styles */
        .d-pad-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            transition: transform 0.1s, background 0.1s;
            user-select: none;
        }
        .d-pad-btn:active, .d-pad-btn.active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }

        .action-btn {
            width: 90px;
            height: 90px;
            background: rgba(239, 68, 68, 0.6); /* Red tint */
            border: 3px solid rgba(255, 100, 100, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);
            transition: transform 0.1s;
            user-select: none;
        }
        .action-btn:active, .action-btn.active {
            background: rgba(239, 68, 68, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(220, 38, 38, 0.6);
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="game-bg"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
            // Game State
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [gameState, setGameState] = useState('playing'); // playing, gameover
            
            // Input State (for visual feedback on buttons)
            const [inputs, setInputs] = useState({ left: false, right: false, punch: false });

            // Refs for game loop logic (to avoid stale closures)
            const playerRef = useRef({ x: 100, y: 0, width: 60, height: 100, velocityX: 0, isPunching: false, facingRight: true });
            const enemyRef = useRef({ x: 300, y: 0, width: 60, height: 100, hp: 100, isHit: false });
            const inputRef = useRef({ left: false, right: false, punch: false });
            const scoreRef = useRef(0);

            // --- INPUT HANDLERS (Touch & Keyboard) ---

            const handleStart = (action) => {
                inputRef.current[action] = true;
                setInputs(prev => ({ ...prev, [action]: true }));
                
                if (action === 'punch') {
                     playerRef.current.isPunching = true;
                     setTimeout(() => { playerRef.current.isPunching = false; }, 200);
                     checkHit();
                }
            };

            const handleEnd = (action) => {
                inputRef.current[action] = false;
                setInputs(prev => ({ ...prev, [action]: false }));
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowLeft') handleStart('left');
                    if (e.key === 'ArrowRight') handleStart('right');
                    if (e.key === ' ' || e.key === 'Enter') handleStart('punch');
                };
                const handleKeyUp = (e) => {
                    if (e.key === 'ArrowLeft') handleEnd('left');
                    if (e.key === 'ArrowRight') handleEnd('right');
                    if (e.key === ' ' || e.key === 'Enter') handleEnd('punch');
                };
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, []);

            // --- GAME LOGIC ---

            const checkHit = () => {
                const p = playerRef.current;
                const e = enemyRef.current;
                
                // Simple collision detection for punch range
                const distance = Math.abs(p.x - e.x);
                const inRange = distance < 80;
                const facingCorrectly = (p.facingRight && e.x > p.x) || (!p.facingRight && e.x < p.x);

                if (inRange && facingCorrectly) {
                    e.isHit = true;
                    e.x += p.facingRight ? 20 : -20; // Knockback
                    scoreRef.current += 10;
                    setScore(scoreRef.current);
                    setTimeout(() => { e.isHit = false; }, 200);
                }
            };

            const update = () => {
                const p = playerRef.current;
                const e = enemyRef.current;
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const groundY = canvas.height - 150;

                // Player Movement
                if (inputRef.current.left) {
                    p.x -= 5;
                    p.facingRight = false;
                }
                if (inputRef.current.right) {
                    p.x += 5;
                    p.facingRight = true;
                }

                // Boundaries
                if (p.x < 0) p.x = 0;
                if (p.x > canvas.width - p.width) p.x = canvas.width - p.width;

                // Enemy Logic (Simple dummy behavior)
                // Keep enemy within bounds
                if (e.x < 0) e.x = 0;
                if (e.x > canvas.width - e.width) e.x = canvas.width - e.width;
                
                // Enemy slowly moves back to center if knocked away
                const center = canvas.width / 2 + 100;
                if (e.x < center) e.x += 1;
                if (e.x > center) e.x -= 1;
            };

            const draw = (ctx) => {
                const canvas = canvasRef.current;
                const p = playerRef.current;
                const e = enemyRef.current;
                const groundY = canvas.height - 150;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Ground
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, groundY + p.height, canvas.width, 20);

                // --- DRAW PLAYER (Hero) ---
                ctx.save();
                ctx.translate(p.x + p.width/2, groundY + p.height/2);
                if (!p.facingRight) ctx.scale(-1, 1);
                
                // Body
                ctx.fillStyle = '#3b82f6'; // Blue Shirt
                ctx.fillRect(-20, 0, 40, 50);
                // Head
                ctx.fillStyle = '#ffccaa';
                ctx.beginPath();
                ctx.arc(0, -10, 15, 0, Math.PI * 2);
                ctx.fill();
                // Arms/Punch
                ctx.fillStyle = '#ffccaa';
                if (p.isPunching) {
                    ctx.fillRect(10, 10, 40, 10); // Punch extended
                } else {
                    ctx.fillRect(0, 10, 10, 30); // Arms down
                }
                // Legs
                ctx.fillStyle = '#1e3a8a'; // Dark pants
                ctx.fillRect(-15, 50, 12, 40);
                ctx.fillRect(3, 50, 12, 40);
                
                ctx.restore();

                // --- DRAW ENEMY (Target) ---
                ctx.save();
                ctx.translate(e.x + e.width/2, groundY + e.height/2);
                
                // Flash red if hit
                ctx.fillStyle = e.isHit ? '#ef4444' : '#4b5563'; 
                ctx.fillRect(-20, 0, 40, 50); // Body
                ctx.fillStyle = e.isHit ? '#fca5a5' : '#9ca3af';
                ctx.beginPath();
                ctx.arc(0, -10, 15, 0, Math.PI * 2); // Head
                ctx.fill();
                
                // Floating Text on Hit
                if (e.isHit) {
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText("POW!", -20, -40);
                }

                ctx.restore();
            };

            const gameLoop = () => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // Responsive Canvas Size
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                update();
                draw(ctx);
                requestAnimationFrame(gameLoop);
            };

            useEffect(() => {
                const loopId = requestAnimationFrame(gameLoop);
                return () => cancelAnimationFrame(loopId);
            }, []);

            return (
                <div className="w-full h-screen relative">
                    
                    {/* HUD */}
                    <div className="absolute top-4 left-4 right-4 flex justify-between items-center z-10">
                        <div className="flex items-center gap-2">
                            <div className="bg-yellow-500 w-12 h-12 rounded-full border-4 border-yellow-300 overflow-hidden shadow-lg">
                                {/* Simple Avatar Placeholder */}
                                <svg viewBox="0 0 24 24" fill="black" className="w-full h-full p-1"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>
                            </div>
                            <div className="flex flex-col">
                                <span className="font-bold text-yellow-400 text-shadow-sm uppercase tracking-wider">Player 1</span>
                                <div className="w-32 h-3 bg-gray-700 rounded-full overflow-hidden border border-gray-500">
                                    <div className="h-full bg-green-500 w-full"></div>
                                </div>
                            </div>
                        </div>

                        <div className="flex flex-col items-end">
                            <span className="text-sm text-gray-300 uppercase tracking-widest">Score</span>
                            <span className="text-4xl font-bold text-white drop-shadow-md">{score}</span>
                        </div>
                    </div>

                    {/* GAME CANVAS */}
                    <canvas ref={canvasRef} className="w-full h-full"></canvas>

                    {/* MOBILE CONTROLS (Always visible for this demo to ensure you see them) */}
                    <div className="absolute bottom-6 left-6 flex gap-4 z-20">
                        <div 
                            className={`d-pad-btn ${inputs.left ? 'active' : ''}`}
                            onTouchStart={(e) => { e.preventDefault(); handleStart('left'); }}
                            onTouchEnd={(e) => { e.preventDefault(); handleEnd('left'); }}
                            onMouseDown={() => handleStart('left')}
                            onMouseUp={() => handleEnd('left')}
                        >
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>
                        </div>
                        <div 
                            className={`d-pad-btn ${inputs.right ? 'active' : ''}`}
                            onTouchStart={(e) => { e.preventDefault(); handleStart('right'); }}
                            onTouchEnd={(e) => { e.preventDefault(); handleEnd('right'); }}
                            onMouseDown={() => handleStart('right')}
                            onMouseUp={() => handleEnd('right')}
                        >
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12h14"/><path d="M12 5l7 7-7 7"/></svg>
                        </div>
                    </div>

                    <div className="absolute bottom-8 right-8 z-20">
                        <div 
                            className={`action-btn ${inputs.punch ? 'active' : ''}`}
                            onTouchStart={(e) => { e.preventDefault(); handleStart('punch'); }}
                            onTouchEnd={(e) => { e.preventDefault(); handleEnd('punch'); }}
                            onMouseDown={() => handleStart('punch')}
                            onMouseUp={() => handleEnd('punch')}
                        >
                            <span className="font-bold text-white tracking-wider text-sm">PUNCH</span>
                        </div>
                    </div>

                    {/* Instructions Overlay (fades out) */}
                    <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none text-center opacity-50">
                        <p className="text-sm">PC: Arrows + Space</p>
                        <p className="text-sm">Mobile: Use Buttons</p>
                    </div>

                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
